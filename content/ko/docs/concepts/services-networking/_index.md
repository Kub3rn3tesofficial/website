---
title: "서비스, 로드밸런싱, 네트워킹"
weight: 60
description: >
  쿠버네티스의 네트워킹에 대한 개념과 리소스에 대해 설명한다.
---

## 쿠버네티스 네트워크 모델

모든 [`Pod`](/ko/docs/concepts/workloads/pods/) 에는 고유의 IP 주소가 있다.
즉, `Pod` 간에 링크를 명시적으로 생성할 필요가 없으며, 컨테이너 포트를 호스트 포트에
매핑할 필요가 거의 없다. 이렇게 하면 호트 할당, 이름 지정, 서비스 검색,
[로드 밸런싱](/ko/docs/concepts/services-networking/ingress/#load-balancing), 애플리케이션
구성 및 마이그레이션 관점에서 `Pod`를 VM 또는 물리 호스트처럼 취급할 수 있는 깔끔하고,
하위 호환성있는 모델을 생성한다.

쿠버네티스는 모든 네트워크 구현에 다음과 같은
기본 요구 사항을 적용한다(의도적 네트워크 세분화 정책 제외).

   * [노드](/ko/docs/concepts/architecture/nodes/)의 파드는 NAT 없이 모든 노드의 모든 파드와 통신할 수 있다.
   * 노드의 에이전트(예: 시스템 데몬, kubelet)는 해당 노드의 모든
     파드와 통신할 수 있다.

참고: 호스트 네트워크에서 실행되는 `Pod` 를 지원하는 리눅스와 같은 플랫폼의 경우, 다음의 요구 사항을
적용한다.

   * 노드의 호스트 네트워크에 있는 파드는 NAT 없이 모든 노드에 있는 모든
     파드와 통신할 수 있다.

이 모델은 전체적으로 덜 복잡할 뿐만 아니라, 쿠버네티스를 위해 VM에서
컨테이너로 애플리케이션을 포팅할 때 충돌이 적게 구현하려는 요구와
주로 호환된다. 잡이 이전에 VM에서 실행된 경우, VM에 IP가 있고
프로젝트의 다른 VM과 통신할 수 있다. 이것은 동일한 기본 모델이다.

쿠버네티스의 IP 주소는 그것의 IP 주소와 MAC 주소를 포함하여 `Pod` 범위에 존재한다(`Pod` 내
컨테이너는 네트워크 네임스페이스를 공유함). 이것은 `Pod` 내 컨테이너가 모두
`localhost` 에서 서로의 포트에 도달할 수 있다는 것을 의미한다. 또한
`Pod` 내부의 컨테이너 포트의 사용을 조정해야하는 것을 의미하지만, 이것도
VM 내의 프로세스와 동일하다. 이것을 "IP-per-pod(파드별 IP)" 모델이라고 한다.

이것이 어떻게 구현되는 지는 사용 중인 특정 컨테이너 런타임의 세부 사항이다.

`Pod` 로 전달하는 `Node` 자체의 포트(호스트 포트라고 함)를
요청할 수 있지만, 이는 매우 틈새 작업이다. 전달이 구현되는 방법은
컨테이너 런타임의 세부 사항이기도 하다. `Pod` 자체는
호스트 포트의 존재 여부에 대해 인식하지 못한다.

쿠버네티스 네트워킹은 다음의 네 가지 문제를 해결한다.
- 파드 내의 컨테이너는 루프백(loopback)을 통한 [네트워킹을 사용하여 통신](/ko/docs/concepts/services-networking/dns-pod-service/)한다.
- 클러스터 네트워킹은 서로 다른 파드 간의 통신을 제공한다.
- [서비스 리소스](/ko/docs/concepts/services-networking/service/)를 사용하면 클러스터 외부에서 [파드에서 실행 중인 애플리케이션에 접근](/ko/docs/concepts/services-networking/connect-applications-service/)할 수 있다.
- 또한 서비스를 사용하여 [클러스터 내부에서 사용할 수 있는 서비스만 게시](/docs/concepts/services-networking/service-traffic-policy/)할 수 있다.
