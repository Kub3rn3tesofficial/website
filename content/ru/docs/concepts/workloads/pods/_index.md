---
title: "Pods"
api_metadata:
- apiVersion: "v1"
  kind: "Pod"
content_type: concept
weight: 10
no_list: true
---

<!-- overview -->

_Pods_ - это самые маленькие развертываемые вычислительные единицы, которые можно создавать и которыми 
можно управлять в Kubernetes.

_Pod_ (как стая китов или гороховый стручок) - это группа из одного или нескольких 
{{< glossary_tooltip text="контейнеров" term_id="container" >}} с общими ресурсами хранения и сети, 
а также спецификация для запуска контейнеров.
Содержимое Pod всегда находится в одном месте, имеет совместное расписание и выполняется в общем 
контексте. Pod моделирует специфический для приложения "логический хост": он содержит один или несколько 
контейнеров приложений, которые относительно тесно связаны между собой.
В необлачных контекстах приложения, выполняемые на одной физической или виртуальной машине, 
аналогичны облачным приложениям, выполняемым на одном логическом хосте.

Помимо контейнеров приложений Pod может содержать 
{{< glossary_tooltip text="init контейнеры" term_id="init-container" >}}, которые запускаются при 
старте Pod. Вы также можете внедрить 
{{< glossary_tooltip text="эфемерные контейнеры" term_id="ephemeral-container" >}} 
для отладки запущенного Pod.

<!-- body -->

## Что такое Pod? {#what-is-a-pod}

{{< note >}}
Вам нужно установить [исполняемую среду контейнеров](/docs/setup/production-environment/container-runtimes/) 
на каждый узел кластера, чтобы на нем могли работать подсистемы.
{{< /note >}}

Общий контекст Pod - это набор пространств имен Linux, cgroups и, возможно, других аспектов изоляции - 
того же, что изолирует {{< glossary_tooltip text="контейнер" term_id="container" >}}. Внутри контекста Pod 
отдельные приложения могут иметь дополнительные субизоляции.

Pod похож на набор контейнеров с общими пространствами имен и общими томами файловой системы.

Pods в кластере Kubernetes используются двумя основными способами:

* **Pods, которые запускают один контейнер**. Модель "один контейнер на Pod" является наиболее 
  распространенным вариантом использования Kubernetes; в этом случае вы можете рассматривать Pod как 
  обертку вокруг одного контейнера; Kubernetes управляет Pods, а не непосредственно контейнерами.
* **Pods, которые запускают несколько контейнеров, обязанных работать вместе**. Pod может инкапсулировать 
  приложение, состоящее из [нескольких расположенных рядом контейнеров](#how-pods-manage-multiple-containers), 
  которые тесно связаны между собой и нуждаются в совместном использовании ресурсов. Эти расположенные 
  рядом контейнеры образуют единое целое.
  
  Группировка нескольких совместно расположенных и совместно управляемых контейнеров в одном Pod - это 
  довольно сложный случай использования. Этот паттерн следует использовать только в особых случаях, когда 
  ваши контейнеры тесно связаны между собой.

  Вам не нужно запускать несколько контейнеров для обеспечения репликации (для обеспечения устойчивости 
  или емкости); если вам нужно несколько реплик, смотрите раздел 
  [Ресурсы рабочей нагрузки](/ru/docs/concepts/workloads/controllers/).

## Использование Pods {#using-pods}

Ниже приведен пример Pod, состоящего из контейнера, в котором запущен образ `nginx:1.14.2`

{{% code_sample file="pods/simple-pod.yaml" %}}

Чтобы создать указанный выше Pod, выполните следующую команду:
```shell
kubectl apply -f https://k8s.io/examples/pods/simple-pod.yaml
```

Pods обычно не создаются напрямую, а создаются с помощью ресурсов рабочей нагрузки. 
Дополнительные сведения о том как использовать Pods с ресурсами рабочей нагрузки, см. в разделе 
[Работа с Pods](#working-with-pods).

### Ресурсы рабочей нагрузки для управления pods {#workload-resources-for-managing-pods}

Обычно вам не нужно создавать Pods напрямую, даже если это Pod-одиночка. Вместо этого создайте их 
с помощью ресурсов рабочей нагрузки, таких как 
{{< glossary_tooltip text="Deployment" term_id="deployment" >}} или 
{{< glossary_tooltip text="Job" term_id="job" >}}. Если вашим Pods необходимо отслеживать состояние, 
рассмотрите ресурс {{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}.


Каждый Pod предназначен для запуска одного экземпляра приложения. Если вы хотите горизонтально 
масштабировать приложение (обеспечить больше общих ресурсов за счет запуска большего количества экземпляров), 
вам следует использовать несколько Pods, по одному для каждого экземпляра. В Kubernetes это обычно называется 
_репликацией_. Реплицированные Pods обычно создаются и управляются как группа ресурсом рабочей нагрузки и его 
{{< glossary_tooltip text="контроллером" term_id="controller" >}}.

Подробнее о том, как Kubernetes использует ресурсы рабочей нагрузки и их контроллеры для масштабирования и 
автовосстановления приложений, читайте в разделе [Pods и контроллеры](#pods-and-controllers).

Pods изначально предоставляют два вида общих ресурсов для входящих в них контейнеров: [сеть](#pod-networking) 
и [хранилище](#pod-storage).

## Работа с Pods {#working-with-pods}

Вы редко будете создавать отдельные Pods непосредственно в Kubernetes-даже Pods-одиночки. Это связано 
с тем, что Pods разработаны как относительно эфемерные, одноразовые сущности. Когда Pod создается 
(непосредственно вами или косвенно {{< glossary_tooltip text="контроллером" term_id="controller" >}}), 
новый Pod планируется к запуску на {{< glossary_tooltip text="узле" term_id="node" >}} в вашем кластере. 
Pod остается на этом узле до тех пор, пока Pod не завершит выполнение, объект Pod не будет удален, 
Pod не будет вытеснен из-за нехватки ресурсов, или узел не выйдет из строя.

{{< note >}}
Не следует путать перезапуск контейнера в Pod с перезапуском Pod. Pod - это не процесс, а среда для 
запуска контейнера(ов). Pod сохраняется до тех пор, пока не будет удален.
{{< /note >}}

Имя Pod должно быть действительным значением 
[имени поддомена DNS](/ru/docs/concepts/overview/working-with-objects/names#dns-subdomain-names), но это 
может привести к неожиданным результатам для имени хоста Pod. Для лучшей совместимости имя должно 
соответствовать более строгим правилам для 
[имен меток DNS](/ru/docs/concepts/overview/working-with-objects/names#dns-label-names).

### Pod OS {#pod-os}

{{< feature-state state="stable" for_k8s_version="v1.25" >}}

В поле `.spec.os.name` следует установить значение `windows` или `linux`, чтобы указать ОС, на которой 
будет работать pod. На данный момент Kubernetes поддерживает только эти две операционные системы. 
В будущем этот список может быть расширен.

В Kubernetes v{{< skew currentVersion >}} значение, заданное для этого поля, не влияет на 
{{< glossary_tooltip text="kube-scheduler" term_id="kube-scheduler" >}} данных pods. 
Задание `.spec.os.name` помогает авторитетно идентифицировать ОС pods и используется для проверки. 
Kubelet отказывается запускать Pod, в котором вы указали ОС Pod, если она не совпадает с операционной 
системой узла, на котором запущен kubelet. 
[Pod Security Standards](/docs/concepts/security/pod-security-standards/) также используют это поле, 
чтобы избежать применения политик, которые не относятся к данной операционной системе.

### Pods и контроллеры {#pods-and-controllers}

Вы можете использовать ресурсы рабочей нагрузки для создания и управления несколькими Pods. Контроллер 
ресурса управляет репликацией и развертыванием, а также автоматическим восстановлением в случае отказа 
Pods. Например, если узел выходит из строя, контроллер замечает, что Pods на этом узле перестали работать, 
и создает замену Pods. Планировщик размещает заменяющий Pod на здоровый узел.

Вот несколько примеров ресурсов рабочей нагрузки, которые управляют одним или несколькими Pods:
* {{< glossary_tooltip text="Deployment" term_id="deployment" >}}
* {{< glossary_tooltip text="StatefulSet" term_id="statefulset" >}}
* {{< glossary_tooltip text="DaemonSet" term_id="daemonset" >}}

### Pod templates {#pod-templates}

Контроллеры {{< glossary_tooltip text="ресурсов рабочей нагрузки" term_id="workload" >}} создают Pods 
из _pod templates_ и управляют этими Pods от вашего имени.

PodTemplates - это спецификации для создания Pods, которые включаются в ресурсы рабочей нагрузки, 
такие как [Deployments](/docs/concepts/workloads/controllers/deployment/), 
[Jobs](/docs/concepts/workloads/controllers/job/) и 
[DaemonSets](/docs/concepts/workloads/controllers/daemonset/).

Каждый контроллер для ресурса рабочей нагрузки использует шаблон `PodTemplate` внутри объекта рабочей 
нагрузки для создания реальных Pods. `PodTemplate` является частью желаемого состояния того ресурса 
рабочей нагрузки, который вы использовали для запуска своего приложения.

При создании Pod вы можете включить в шаблон Pod 
[переменные окружения](/docs/tasks/inject-data-application/define-environment-variable-container/) 
для контейнеров, запускаемых в Pod.

Приведенный ниже пример представляет собой манифест для простого Job с `template`, который запускает 
один контейнер. Контейнер в этом Pod печатает сообщение, затем приостанавливается.

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: hello
spec:
  template:
    # This is the pod template
    spec:
      containers:
      - name: hello
        image: busybox:1.28
        command: ['sh', '-c', 'echo "Hello, Kubernetes!" && sleep 3600']
      restartPolicy: OnFailure
    # The pod template ends here
```

Изменение шаблона pod или переход на новый шаблон pod не оказывает прямого влияния на уже существующие 
Pods. Если вы измените pod template для ресурса рабочей нагрузки, этот ресурс должен будет создать замену 
Pods, использующих обновленный шаблон.

Например, контроллер StatefulSet следит за тем, чтобы запущенные Pods соответствовали текущему pod template 
для каждого объекта StatefulSet. Если вы отредактируете StatefulSet, чтобы изменить его pod template, 
StatefulSet начнет создавать новые Pods на основе обновленного template. В конце концов, все старые 
Pods заменяются новыми, и обновление завершается.

Каждый ресурс рабочей нагрузки реализует свои собственные правила обработки изменений Pod template. 
Если вы хотите узнать больше о StatefulSet, ознакомьтесь с 
[Updating StatefulSets ](/docs/tutorials/stateful-application/basic-stateful-set/#updating-statefulsets) 
в учебном пособии "StatefulSet Basics".

На Узлах {{< glossary_tooltip term_id="kubelet" text="kubelet" >}} не наблюдает и не управляет 
непосредственно деталями pod templates и обновлений pod; эти детали абстрагированы. Такая абстракция и 
разделение интересов упрощает семантику системы и делает возможным расширение поведения кластера без 
изменения существующего кода.

## Обновление и замена Pod {#pod-update-and-replacement}

Как уже говорилось в предыдущем разделе, при изменении Pod template для ресурса рабочей нагрузки 
контроллер создает новые Pods на основе обновленного шаблона вместо того, чтобы обновлять или 
исправлять существующие Pods.

Kubernetes не мешает вам управлять Pods напрямую. Можно обновить некоторые поля запущенного Pods 
на месте. Однако операции обновления Pods, такие как 
[`patch`](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#patch-pod-v1-core) и 
[`replace`](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#replace-pod-v1-core), 
имеют некоторые ограничения:

- Большинство метаданных о Pods неизменяемы. Например, вы не можете изменить поля `namespace`, `name`, 
  `uid` или `creationTimestamp`; поле `generation` уникально. Оно принимает только те обновления, 
  которые увеличивают текущее значение поля.
- Если установлено значение `metadata.deletionTimestamp`, то в список `metadata.finalizers` не может 
  быть добавлена новая запись.
- Обновления Pods не могут изменять поля, кроме `spec.containers[*].image`, 
  `spec.initContainers[*].image`, `spec.activeDeadlineSeconds` или `spec.tolerations`. 
  Для `spec.tolerations` можно только добавлять новые записи.
- При обновлении поля `spec.activeDeadlineSeconds` допускается два типа обновлений:

  1. установка положительного значения для неназначенного поля;
  2. обновление поля с положительного числа на меньшее неотрицательное число.

## Совместное использование ресурсов и коммуникация {#resource-sharing-and-communication}

Pods позволяют обмениваться данными и взаимодействовать между входящими в них контейнерами.

### Хранение в Pods {#pod-storage}

Pod может определять набор общих {{< glossary_tooltip text="томов" term_id="volume" >}} хранения. 
Все контейнеры в Pod могут получить доступ к общим томам, что позволяет им обмениваться данными. 
Тома также позволяют сохранять данные в Pod в случае необходимости перезапуска одного из контейнеров. 
Дополнительные сведения о том, как Kubernetes реализует общее хранилище и делает его доступным для 
Pods, см. в разделе [Storage](/docs/concepts/storage/).

### Pod networking {#pod-networking}

Каждому Pod назначается уникальный IP-адрес для каждого семейства адресов. Каждый контейнер в Pod 
разделяет сетевое пространство имен, включая IP-адрес и сетевые порты. Внутри Pod (и **только** в нем) 
контейнеры, входящие в Pod, могут взаимодействовать друг с другом, используя `localhost`. Когда 
контейнеры в Pod общаются с сущностями *за пределами Pod*, они должны координировать использование 
общих сетевых ресурсов (например, портов). Внутри Pod контейнеры имеют общий IP-адрес и порт, и могут 
найти друг друга через localhost. Контейнеры в Pod также могут взаимодействовать друг с другом, 
используя стандартные межпроцессные взаимодействия, такие как семафоры SystemV или общая память POSIX. 
Контейнеры в разных Pods имеют разные IP-адреса и не могут взаимодействовать по IPC на уровне ОС без 
специальной настройки. Контейнеры, которые хотят взаимодействовать с контейнером, запущенным в другом 
Pod, могут использовать IP-сети для коммуникации.

Контейнеры в Pods воспринимают системное имя хоста как то же самое, что и сконфигурированный `name` 
для Pod. Подробнее об этом в разделе 
[Сеть в кластере](/ru/docs/concepts/cluster-administration/networking/).

## Привилегированный режим для контейнеров {#privileged-mode-for-containers}

{{< note >}}
Для того чтобы эта настройка была актуальной, ваша 
{{< glossary_tooltip text="иcполняемая среда контейнеров" term_id="container-runtime" >}} должна 
поддерживать концепцию привилегированного контейнера.
{{< /note >}}

Любой контейнер в pod может работать в привилегированном режиме, чтобы использовать 
административные возможности операционной системы, которые иначе были бы недоступны. Это доступно 
как для Windows, так и для Linux.

### Привилегированные контейнеры в Linux {#linux-privileged-containers}

В Linux любой контейнер в Pod может включить привилегированный режим с помощью флага `privileged` 
(Linux) в [контексте безопасности](/docs/tasks/configure-pod-container/security-context/) 
спецификации контейнера. Это полезно для контейнеров, которые хотят использовать возможности 
администрирования операционной системы, такие как работа с сетевым стеком или доступ к аппаратным 
устройствам.

### Привилегированные контейнеры в Windows {#windows-privileged-containers}

{{< feature-state for_k8s_version="v1.26" state="stable" >}}

В Windows вы можете создать 
[Windows HostProcess pod](/docs/tasks/configure-pod-container/create-hostprocess-pod), установив 
флаг `windowsOptions.hostProcess` в контексте безопасности спецификации pod. Все контейнеры в этих 
pods должны работать как контейнеры Windows HostProcess. HostProcess pods запускаются 
непосредственно на хосте и могут использоваться для выполнения административных задач, как это 
делается с привилегированными контейнерами Linux.

## Статические Pods {#static-pods}

_Статические Pods_ управляются непосредственно демоном kubelet на определенном узле, без наблюдения 
со стороны {{< glossary_tooltip text="API-сервера" term_id="kube-apiserver" >}}. В то время как 
большинство Pods управляются управляющим слоем (Control Plane) (например, 
{{< glossary_tooltip text="Deployment" term_id="deployment" >}}), для статических Pods kubelet 
непосредственно контролирует каждый статический Pod (и перезапускает его в случае сбоя).

Статические Pods всегда привязаны к одному {{< glossary_tooltip term_id="kubelet" >}} на определенном 
узле. Основное применение статических Pods - запуск самодостаточного управляющего слоя (Control Plane): 
другими словами, использование kubelet для контроля отдельных 
[компонентов управляющего слоя](/ru/docs/concepts/overview/components/#control-plane-components).

Kubelet автоматически пытается создать {{< glossary_tooltip text="зеркальный Pod" term_id="mirror-pod" >}} 
на API-сервере Kubernetes для каждого статического Pod. Это означает, что запущенные на узле Pods 
видны на API-сервере, но управлять ими оттуда нельзя. Дополнительную информацию см. в руководстве 
[Create static Pods](/docs/tasks/configure-pod-container/static-pod).

{{< note >}}
В `spec` статического Pod нельзя ссылаться на другие объекты API (например, 
{{< glossary_tooltip text="ServiceAccount" term_id="service-account" >}}, 
{{< glossary_tooltip text="ConfigMap" term_id="configmap" >}}, 
{{< glossary_tooltip text="Secret" term_id="secret" >}} и т.д.).
{{< /note >}}

## Pods с несколькими контейнерами {#how-pods-manage-multiple-containers}

Pods предназначены для поддержки нескольких взаимодействующих процессов (в виде контейнеров), которые 
образуют единое целое. Контейнеры в Pod автоматически размещаются и планируются на одной и той же 
физической или виртуальной машине в кластере. Контейнеры могут совместно использовать ресурсы и 
зависимости, взаимодействовать друг с другом и координировать, когда и как они завершаются.

<!--intentionally repeats some text from earlier in the page, with more detail -->

Pods в кластере Kubernetes используются двумя основными способами:

* **Pods, которые запускают один контейнер**. Модель "один контейнер на Pod" является наиболее 
  распространенным вариантом использования Kubernetes; в этом случае вы можете рассматривать Pod как 
  обертку вокруг одного контейнера; Kubernetes управляет Pods, а не непосредственно контейнерами.
* **Pods, которые запускают несколько контейнеров, обязанных работать вместе**. Pod может инкапсулировать 
  приложение, состоящее из нескольких расположенных рядом контейнеров, которые тесно связаны между 
  собой и нуждаются в совместном использовании ресурсов. Эти совместно расположенные контейнеры образуют 
  единую целостную единицу обслуживания - например, один контейнер обслуживает данные, хранящиеся в 
  общем томе, а отдельный {{< glossary_tooltip text="sidecar контейнер" term_id="sidecar-container" >}} 
  обновляет эти файлы. Pod объединяет эти контейнеры, ресурсы хранения и эфемерный сетевой идентификатор 
  в единое целое.

Например, у вас может быть контейнер, выполняющий роль веб-сервера для файлов на общем томе, и 
отдельный [sidecar контейнер](/docs/concepts/workloads/pods/sidecar-containers/), который обновляет эти 
файлы из удаленного источника, как показано на следующей схеме:

{{< figure src="/images/docs/pod.svg" alt="Pod creation diagram" class="diagram-medium" >}}

В некоторых Pods есть {{< glossary_tooltip text="init контейнеры" term_id="init-container" >}}, 
а также {{< glossary_tooltip text="app контейнеры" term_id="app-container" >}}. По умолчанию 
init контейнеры запускаются и завершаются до запуска app контейнеров.

Вы также можете иметь [sidecar контейнеры](/docs/concepts/workloads/pods/sidecar-containers/), 
которые предоставляют вспомогательные услуги для основного приложения Pod (например, service mesh).

{{< feature-state for_k8s_version="v1.29" state="beta" >}}

Включенный по умолчанию, `SidecarContainers` 
[feature gate](/docs/reference/command-line-tools-reference/feature-gates/) позволяет указать 
`restartPolicy: Always` для init контейнеров. Установка политики перезапуска `Always` гарантирует, 
что контейнеры, для которых вы ее задали, будут рассматриваться как _sidecar контейнеры_, которые 
будут работать в течение всего времени существования Pod. Контейнеры, которые вы явно определили как 
sidecar контейнеры, запускаются раньше Pod основного приложения и остаются запущенными до тех пор, 
пока Pod не будет выключен.

## Probes контейнера {#container-probes}

_Probe_ - это диагностика, периодически выполняемая kubelet для контейнера. Для проведения диагностики 
kubelet может вызывать различные действия:

- `ExecAction` (выполняется с помощью иcполняемой среды контейнеров)
- `TCPSocketAction` (проверку производит kubelet)
- `HTTPGetAction` (проверку производит kubelet)

Подробнее о [probes](/docs/concepts/workloads/pods/pod-lifecycle/#container-probes) вы можете прочитать 
в документации Pod Lifecycle.

## {{% heading "whatsnext" %}}

* Ознакомьтесь с [lifecycle of a Pod](/docs/concepts/workloads/pods/pod-lifecycle/).
* Ознакомьтесь с [RuntimeClass](/docs/concepts/containers/runtime-class/) и с тем, как его 
  использовать для настройки различных Pods с различными конфигурациями времени выполнения контейнеров.
* Ознакомьтесь с [PodDisruptionBudget](/docs/concepts/workloads/pods/disruptions/) и с тем, как с его 
  помощью можно управлять доступностью приложений во время сбоев.
* Pod - это ресурс верхнего уровня в Kubernetes REST API. Определение объекта 
  {{< api-reference page="workload-resources/pod-v1" >}} подробно описывает данный ресурс.
* [The Distributed System Toolkit: Patterns for Composite Containers](/blog/2015/06/the-distributed-system-toolkit-patterns/) 
  объясняет общие компоновки для Pods с более чем одним контейнером.
* Ознакомьтесь с 
  [Pod topology spread constraints](/docs/concepts/scheduling-eviction/topology-spread-constraints/).

Чтобы понять, почему Kubernetes оборачивает общий Pod API в другие ресурсы (такие как 
{{< glossary_tooltip text="StatefulSets" term_id="statefulset" >}} или 
{{< glossary_tooltip text="Deployments" term_id="deployment" >}}), вы можете прочитать о 
предшествующем уровне техники, включая:

* [Aurora](https://aurora.apache.org/documentation/latest/reference/configuration/#job-schema)
* [Borg](https://research.google.com/pubs/pub43438.html)
* [Marathon](https://mesosphere.github.io/marathon/docs/rest-api.html)
* [Omega](https://research.google/pubs/pub41684/)
* [Tupperware](https://engineering.fb.com/data-center-engineering/tupperware/).