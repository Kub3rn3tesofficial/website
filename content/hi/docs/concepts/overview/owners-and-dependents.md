---
title : मालिक और आश्रित
---


कुबरनेटीज़ में, कुछ ऑब्जेक्ट्स दूसरे ऑब्जेक्ट्स के मालिक होते हैं। उदाहरण के लिए, एक ReplicaSet पॉड्स के एक सेट के मालिक होता है। ये मालिक ऑब्जेक्ट्स अपने मालिक के डिपेंडेंट्स होते हैं।

मालिकी और लेबल और सिलेक्टर मेकेनिज़्म से अलग होती है। उदाहरण के लिए, एक सर्विस जो EndpointSlice ऑब्जेक्ट्स बनाता है। सर्विस लेबल्स का उपयोग करता है ताकि कंट्रोल प्लेन तय कर सके कि कौन से EndpointSlice ऑब्जेक्ट्स उस सर्विस के लिए उपयोग किए जाते हैं। लेबल्स के अलावा, हर EndpointSlice जो सर्विस के पक्ष में प्रबंधित होता है, उसका एक मालिक संदर्भ होता है। मालिक संदर्भ कुबरनेटीज़ के विभिन्न हिस्सों को ऑब्जेक्ट्स की बिना उन्हें नियंत्रण करने में मदद करता है जिन्हें वे नियंत्रण नहीं करते हैं।

## ऑब्जेक्ट स्पेसिफिकेशन में मालिक संदर्भ

डिपेंडेंट ऑब्जेक्ट्स के पास एक metadata.ownerReferences फ़ील्ड होता है जो उनके मालिक ऑब्जेक्ट का संदर्भ करता है। एक मान्य मालिक संदर्भ डिपेंडेंट ऑब्जेक्ट के समान नेमस्पेस के अंदर ऑब्जेक्ट नाम और एक UID से मिलकर बनता है। कुबरनेटीज़ उन ऑब्जेक्ट्स के लिए इस फ़ील्ड की मूल्य स्वचालित रूप से सेट करता है जो अन्य ऑब्जेक्ट्स के डिपेंडेंट्स होते हैं, जैसे कि ReplicaSets, DaemonSets, Deployments, Jobs और CronJobs, और ReplicationControllers। आप इन रिश्तों को इस फ़ील्ड की मूल्य को बदलकर मैन्युअली भी कॉन्फ़िगर कर सकते हैं। हालांकि, आपको आमतौर पर इन रिश्तों को कुबरनेटीज़ को स्वचालित रूप से प्रबंधित करने देने की आवश्यकता नहीं होती और आप कुबरनेटीज़ को रिश्तों को स्वचालित रूप से प्रबंधित करने देते हैं।

डिपेंडेंट ऑब्जेक्ट्स के पास एक ownerReferences.blockOwnerDeletion फ़ील्ड भी होता है जो एक बूलियन मूल्य लेता है और निश्चित डिपेंडेंट्स क्या उनके मालिक ऑब्जेक्ट को हटाने से रोक सकते हैं। कुबरनेटीज़ खुद को ownerReferences.blockOwnerDeletion=true की मूल्य सेट करता है जब कोई कंट्रोलर (उदाहरण के लिए, डिप्लॉयमेंट कंट्रोलर) metadata.ownerReferences फ़ील्ड का मूल्य सेट करता है। आप ब्लॉकऑवनरडिलीशन फ़ील्ड के मूल्य को मैन्युअली भी सेट कर सकते हैं ताकि आप नियंत्रण कर सकें कि कौन से डिपेंडेंट्स गार्बेज कलेक्शन को ब्लॉक करते हैं।

कुबरनेटीज़ एडमिशन कंट्रोलर डिपेंडेंट संसाधनों के इस फ़ील्ड को बदलने के लिए उपयोगकर्ता उपयोग की अनुमति को नियंत्रित करता है, मालिक की मिटाने की अनुमतियों के आधार पर। यह नियंत्रण अनधिकृत उपयोगकर्ताओं को मालिक ऑब्जेक्ट हटाने की प्रक्रिया को रोकने से बचाता है।

### नोट:

डिज़ाइन के आधार पर, क्रॉस-नेमस्पेस मालिक संदर्भ अनुमत नहीं हैं। नेमस्पेस्ड डिपेंडेंट्स क्लस्टर-स्कोप्ड या नेमस्पेस्ड मालिकों को निर्दिष्ट कर सकते हैं। नेमस्पेस्ड मालिक को डिपेंडेंट के समान नेमस्पेस में मौजूद होना चाहिए। यदि यह नहीं होता है, तो मालिक संदर्भ को अनुपस्थित माना जाता है, और डिपेंडेंट को हटाने के बाद सभी मालिकों की अनुमति की जाँच होने पर हटाया जाता है।

क्लस्टर-स्कोप्ड डिपेंडेंट्स केवल क्लस्टर-स्कोप्ड मालिकों को निर्दिष्ट कर सकते हैं। v1.20+ में, यदि क्लस्टर-स्कोप्ड डिपेंडेंट एक नेमस्पेस्ड किंड को मालिक के रूप में निर्दिष्ट करता है, तो इसे अनिर्वाचनीय मालिक संदर्भ के रूप में देखा जाता है, और गार्बेज कलेक्टने की क्षमता नहीं होती है।

v1.20+ में, अगर गार्बेज कलेक्टर एक अमान्य क्रॉस-नेमस्पेस मालिक संदर्भ का पता लगाता है, या एक क्लस्टर-स्कोप्ड डिपेंडेंट को एक नेमस्पेस्ड किंड के ownerReference का संदर्भ रिपोर्ट होता है, तो वर्निंग ईवेंट OwnerRefInvalidNamespace के रूप में होती है और एक अमान्य डिपेंडेंट के involvedObject के साथ रिपोर्ट होती है। आप ऐसे प्रकार के ईवेंट की जाँच कर सकते

 हैं जिसके लिए kubectl get events -A --field-selector=reason=OwnerRefInvalidNamespace को चला कर मिलते हैं।

## मालिकी और फाइनलाइजर्स

जब आप कुबरनेटीज़ को किसी संसाधन को हटाने के लिए कहते हैं, तो API सर्वर इस संसाधन के लिए किसी भी फाइनलाइजर नियम को प्रोसेस करने की मैनेजिंग कंट्रोलर को अनुमति देता है। फाइनलाइजर संसाधनों के अनजाने में हटाए जाने से बचाते हैं, जिनकी आपके क्लस्टर को सही तरीके से काम करने के लिए आवश्यकता हो सकती है। उदाहरण के लिए, यदि आप कोशिश करते हैं कि एक पॉड द्वारा अभी भी उपयोग में होने वाले एक PersistentVolume को हटाएं, तो हटाना तुरंत नहीं होता है क्योंकि PersistentVolume पर कुबरनेटीज़.आईओ/पीवी-प्रोटेक्शन फाइनलाइजर होता है। इसके बजाय, वॉल्यूम को Terminating स्थिति में रहने दिया जाता है जब तक कुबरनेटीज़ फाइनलाइजर को साफ़ नहीं करता, जो केवल तब होता है जब PersistentVolume को पॉड से बंद नहीं किया जाता है।

कुबरनेटीज़ भी foreground या orphan कास्केडिंग हटाने का उपयोग करते समय मालिक संसाधनों के लिए फाइनलाइजर्स जोड़ता है। foreground हटाने में, यह मालिक को हटाने से पहले विगतवर्ष फाइनलाइजर जोड़ता है, ताकि कंट्रोलर को मालिक को हटाने से पहले ownerReferences.blockOwnerDeletion=true वाले डिपेंडेंट संसाधनों को हटाना हो। यदि आप एक orphan हटाने की नीति निर्दिष्ट करते हैं, तो कुबरनेटीज़ उपन्यास फाइनलाइजर जोड़ता है ताकि कंट्रोलर मालिक ऑब्जेक्ट को हटाने के बाद डिपेंडेंट संसाधनों को नजरअंदाज करे।


