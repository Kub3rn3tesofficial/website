---
title : कुबेरनेट्स में ऑब्जेक्ट्स?
---

इस पृष्ठ में बताया गया है कि कुबेरनेट्स ऑब्जेक्ट्स को कुबेरनेट्स API में कैसे प्रस्तुत किया जाता है, और आप .yaml प्रारूप में उन्हें कैसे व्यक्त कर सकते हैं।

## कुबेरनेट्स ऑब्जेक्ट्स की समझ

कुबेरनेट्स ऑब्जेक्ट्स कुबेरनेट्स सिस्टम में स्थायी इकाइयाँ होती हैं। कुबेरनेट्स इन इकाइयों का उपयोग आपके क्लस्टर की स्थिति को प्रस्तुत करने के लिए करता है। विशेष रूप से, वे विवरण दे सकते हैं:

* कौन से कंटेनराइज़ड एप्लिकेशन चल रहे हैं (और किन नोडों पर)
* उन एप्लिकेशनों के लिए उपलब्ध संसाधन
* उन एप्लिकेशनों के व्यवहार के चार ओर नीतियाँ, जैसे पुनरारंभ नीतियाँ, अपग्रेड और दोष-सहिष्णुता

कुबरनेटीज़ ऑब्जेक्ट एक "इरादे की रिकॉर्ड" है - एक बार जब आप ऑब्जेक्ट बनाते हैं, तो कुबरनेटीज़ सिस्टम लगातार काम करेगा ताकि वह ऑब्जेक्ट मौजूद हो। एक ऑब्जेक्ट बनाने के द्वारा, आप वास्तव में कुबरनेटीज़ सिस्टम को बता रहे हैं कि आपके क्लस्टर का वर्कलोड कैसे दिखना चाहते हैं; यह आपके क्लस्टर की इच्छित स्थिति है।

कुबरनेटीज़ ऑब्जेक्ट्स के साथ काम करने के लिए - चाहे उन्हें बनाने, संशोधित करने, या हटाने के लिए हो - आपको कुबरनेटीज़ API का उपयोग करना होगा। उदाहरण के लिए, कॉमांड-लाइन इंटरफेस का उपयोग करने के लिए kubectl जब आप करते हैं, तो CLI आपके लिए कुबरनेटीज़ API कोल करता है। आप भी क्लाइंट लाइब्रेरी का उपयोग करके अपने खुद के प्रोग्राम में कुबरनेटीज़ API का सीधा उपयोग कर सकते हैं।

## ऑब्जेक्ट स्पेक और स्टेटस

लगभग हर कुबरनेटीज़ ऑब्जेक्ट में दो नेस्टेड ऑब्जेक्ट फ़ील्ड्स होते हैं जो ऑब्जेक्ट के कॉन्फ़िगरेशन को नियंत्रित करते हैं: ऑब्जेक्ट स्पेक और ऑब्जेक्ट स्टेटस। जो ऑब्जेक्ट्स के लिए स्पेक होता है, तो जब आप ऑब्जेक्ट बनाते हैं, तो आपको इसे सेट करना होता है, रिसोर्स के विशेषता का विवरण प्रदान करना होता है: इसकी इच्छित स्थिति।

स्थिति वर्तमान ऑब्जेक्ट की वस्तविक स्थिति का वर्णन करती है, जिसे कुबरनेटीज़ सिस्टम और उसके कॉम्पोनेंट्स द्वारा प्रदान और अपडेट किया जाता है। कुबरनेटीज़ कंट्रोल प्लेन हर ऑब्जेक्ट की वास्तविक स्थिति को आपकी स्पेक के अनुसार मेल कराने के लिए लगातार और सक्रिय रूप से प्रबंधित करता है।

उदाहरण के लिए: कुबरनेटीज़ में, एक डिप्लॉयमेंट एक ऑब्जेक्ट है जो आपके क्लस्टर पर चल रहे एक एप्लिकेशन को प्रतिष्ठित कर सकता है। जब आप डिप्लॉयमेंट बनाते हैं, तो आप डिप्लॉयमेंट स्पेक को सेट कर सकते हैं कि आप चाहते हैं कि आपके एप्लिकेशन के तीन रिप्लिका चल रहे हों। कुबरनेटीज़ सिस्टम डिप्लॉयमेंट स्पेक को पढ़ता है और आपकी स्पेक को मेल करने के लिए आपकी इच्छित एप्लिकेशन के तीन इंस्टेंस शुरू करता है - स्थिति को आपकी स्पेक से मेल करने के लिए अपडेट करता है। अगर उनमें से कोई भी इंस्टेंस फेल हो जाए (स्थिति में परिवर्तन हो), तो कुबरनेटीज़ सिस्टम स्पेक और स्थिति के बीच के अंतर के उत्तराधिकार के साथ कार्रवाई करता है - इस मामले में एक प्रतिस्थापन इंस्टेंस शुरू करके।

ऑब्जेक्ट स्पेक, स्थिति, और मेटाडेटा के अधिक जानकारी के लिए, कुबरनेटीज़ एपीआई नियमों को देखें।

## कुबरनेटीज़ ऑब्जेक्ट का विवरण

जब आप कुबरनेटीज़ में एक ऑब्जेक्ट बनाते हैं, तो आपको उसकी इच्छित स्थिति का विवरण देना होता है, साथ ही ऑब्जेक्ट के बारे में कुछ मूल जानकारी (जैसे नाम)। जब आप कुबरनेटीज़ API का उपयोग करके ऑब्जेक्ट बनाते हैं (सीधे या kubectl के माध्यम से), तो उस API अनुरोध में उस जानकारी को JSON रूप में अनुरोध बॉडी में शामिल करना होता है। अधिकांशत: आप मानिफ़ेस्ट के रूप में जानकारी को प्रदान करते हैं, जो आमतौर पर YAML होते हैं (आप JSON प्रारूप का भी उपयोग कर सकते हैं)। उपकरण जैसे कि kubectl जानकारी को मानिफ़ेस्ट से JSON या किसी अन्य समर्थित सीरीयलाइज़ेशन प्रारूप में परिवर्तित करते हैं, ज

ब वे HTTP के माध्यम से API अनुरोध करते हैं।

यहां एक उदाहरण मानिफ़ेस्ट है जिसमें एक कुबेरनेट्स डिप्लॉयमेंट के लिए आवश्यक फ़ील्ड्स और ऑब्जेक्ट स्पेक दिखाता है:

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  selector:
    matchLabels:
      app: nginx
  replicas: 2 # tells deployment to run 2 pods matching the template
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:1.14.2
        ports:
        - containerPort: 80

एक ऐसा तरीका जिससे एक मानिफ़ेस्ट फ़ाइल का उपयोग करके उपरोक्त जैसा डिप्लॉयमेंट बनाने के लिए है, कुबरनेटीज़ कमांड-लाइन इंटरफेस में kubectl apply कमांड का उपयोग करना है, जिसमें .yaml फ़ाइल को एक आर्ग्यूमेंट के रूप में पास किया जाता है। यहां एक उदाहरण है:


``` kubectl apply -f https://k8s.io/examples/application/deployment.yaml ```

आउटपुट इसके समान होता है:

मानिफ़ेस्ट (YAML या JSON फ़ाइल) में, जिस कुबेरनेट्स ऑब्जेक्ट को बनाना चाहते हैं, उसके लिए आपको निम्नलिखित फ़ील्ड्स के लिए मूल्य सेट करने की आवश्यकता होगी:

apiVersion - इस ऑब्जेक्ट को बनाने के लिए आप किस कुबेरनेट्स API की संस्करण का उपयोग कर रहे हैं
kind - आप किस प्रकार का ऑब्जेक्ट बनाना चाहते हैं
metadata - इस ऑब्जेक्ट को पहचानने में मदद करने वाला डेटा, जिसमें एक नाम स्ट्रिंग, UID, और वैकल्पिक नेमस्पेस शामिल होता है
spec - आपकी इच्छित स्थिति के लिए ऑब्जेक्ट
ऑब्जेक्ट स्पेक का ठीक रूप हर कुबेरनेट्स ऑब्जेक्ट के लिए अलग होता है, और उस ऑब्जेक्ट के लिए विशिष्ट नेस्टेड फ़ील्ड्स शामिल होते हैं। कुबेरनेट्स API संदर्भ आपको कुबेरनेट्स का उपयोग करके बना सकने वाले सभी ऑब्जेक्ट्स के लिए स्पेक प्रारूप को खोजने में मदद कर सकता है।

उदाहरण के लिए, Pod API संदर्भ के लिए स्पेक फ़ील्ड देखें। प्रत्येक पॉड के लिए, .spec फ़ील्ड पॉड और उसकी इच्छित स्थिति को निर्दिष्ट करता है (जैसे प्रत्येक पॉड के भीतर हर कंटेनर के लिए कंटेनर इमेज का नाम)। एक और ऑब्जेक्ट स्पेसिफिकेशन का उदाहरण है StatefulSet API के लिए स्पेक फ़ील्ड। StatefulSet के लिए, .spec फ़ील्ड StatefulSet और उसकी इच्छित स्थिति को निर्दिष्ट करता है। StatefulSet के .spec के भीतर एक पॉड ऑब्जेक्ट्स के लिए एक टेम्प्लेट होता है। वह टेम्प्लेट StatefulSet नियंत्रक द्वारा StatefulSet निर्दिष्टि को पूरा करने के लिए बनाए जाने वाले पॉड्स का विवरण करता है। विभिन्न प्रकार के ऑब्जेक्ट भी विभिन्न .status हो सकते हैं; फिर भी, API संदर्भ पृष्ठ इस .status फ़ील्ड के संरचना की और विभिन्न प्रकार के ऑब्जेक्ट के लिए इसके सामग्री की विस्तार जानकारी प्रदान करते हैं।

ध्यान दें: अधिक जानकारी के लिए YAML कॉन्फ़िगरेशन फ़ाइल लिखने के संबंध में कॉन्फ़िगरेशन बेस्ट प्रैक्टिस देखें।

सर्वर साइड फ़ील्ड मान्यता
कुबेरनेट्स v1.25 के साथ शुरू होते हुए, API सर्वर अपरिचित या डुप्लिकेट फ़ील्ड्स को एक ऑब्जेक्ट में पहचान स्तर फ़ील्ड मान्यता का पता

 लगाता है। यह सर्वर साइड पर kubectl --validate की सभी विशेषताएँ प्रदान करता है।

kubectl टूल सर्वर साइड फ़ील्ड मान्यता के स्तर को सेट करने के लिए --validate फ़्लैग का उपयोग करता है। यह इग्नोर, वार्न, और स्ट्रिक्ट के मान्यता स्तर को स्वीकार करता है, साथ ही सच्चे (स्ट्रिक्ट के समकक्ष) और झूठे (इग्नोर के समकक्ष) मान्यता को भी स्वीकार करता है। kubectl के लिए डिफ़ॉल्ट मान्यता सेटिंग --validate=true है।

स्ट्रिक्ट सख्त फ़ील्ड मान्यता, मान्यता में त्रुटियाँ होने पर त्रुटियों को दिखाता है वार्न फ़ील्ड मान्यता की जाती है, लेकिन त्रुटियाँ त्रुटियों की बजाय चेतावनियों के रूप में दिखाई देती हैं इग्नोर कोई सर्वर साइड फ़ील्ड मान्यता नहीं की जाती है जब kubectl कोई API सर्वर से जुड़ नहीं सकता है जो ऑब्जेक्ट में फ़ील्ड मान्यता का समर्थन करता है, तो यह खुद की ओर से क्लाइंट-साइड मान्यता का उपयोग करने की तरफ़ जाएगा। कुबेरनेट्स 1.27 और बाद के संस्करण हमेशा फ़ील्ड मान्यता प्रदान करते हैं; पुराने कुबेरनेट्स रिलीज़ किसी किस्म की समय मान्यता प्रदान नहीं कर सकते हैं। यदि आपका क्लस्टर v1.27 से पुराना है, तो अपने कुबेरनेट्स संस्करण के लिए दस्तावेज़ देखें।



