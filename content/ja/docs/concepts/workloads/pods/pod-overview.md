---
reviewers:
- erictune
title: ポッドについての概観(Pod Overview)
content_template: templates/concept
weight: 10
card: 
  name: concepts
  weight: 60
---

{{% capture overview %}}
このページでは、Kubernetesのオブジェクトモデルにおいて、デプロイ可能な最小単位のオブジェクトである`ポッド`に関して概観します。
{{% /capture %}}


{{% capture body %}}
## ポッドについて理解する

*ポッド* は、Kubernetesの基本的なビルディングブロックとなります。Kubernetesオブジェクトモデルの中で、ユーザが作成し、デプロイ可能なシンプルで最も最小のユニットです。単一のポッドはクラスタ上で稼働する単一のプロセスを表現します。

単一のポッドは、アプリケーションコンテナ（いくつかの場合においては複数のコンテナ）や、ストレージリソース、ユニークなネットワークIPや、コンテナがどのように稼働すべきか統制するためのオプションをカプセル化します。単一のポッドは、ある単一のデプロイメントのユニット(単一のコンテナもしくはリソースを共有する、密接に連携された少数のコンテナ群を含むような*Kubernetes内でのアプリケーションの単一のインスタンス*) を表現します。  

> [Docker](https://www.docker.com)はKubernetesのポッド内で使われる最も一般的なコンテナランタイムですが、ポッドは他のコンテナランタイムも同様にサポートしています。    


Kubernetesクラスタ内でのポッドは2つの主な方法で使うことができます。

* **単一のコンテナを稼働させるポッド** : いわゆる*「1ポッド1コンテナ」* 構成のモデルは、最も一般的なKubernetesのユースケースです。  
このケースでは、ユーザはポッドを単一のコンテナのラッパーとして考えることができ、Kubernetesはコンテナを直接扱うというよりは、ポッドを管理することになります。
* **協調して稼働させる必要がある複数のコンテナを稼働させるポッド** : 単一のポッドは、リソースを共有する必要があるような、密接に連携した複数の同じ環境にあるコンテナからなるアプリケーションをカプセル化することもできます。  これらの同じ環境にあるコンテナ群は、サービスの結合力の強いユニットを構成することができます。  
-- 1つのコンテナが、共有されたボリュームからファイルをパブリックな場所に送信し、一方では分割された*サイドカー* コンテナがそれらのファイルを更新します。そのポッドはそれらのコンテナとストレージリソースを、単一の管理可能なエンティティとしてまとめます。

[Kubernetes Blog](http://kubernetes.io/blog)にて、ポッドのユースケースに関するいくつかの追加情報を見ることができます。  
さらなる情報を得たい場合は、下記のページを参照ください。  

* [The Distributed System Toolkit: Patterns for Composite Containers](https://kubernetes.io/blog/2015/06/the-distributed-system-toolkit-patterns)  
* [Container Design Patterns](https://kubernetes.io/blog/2016/06/container-design-patterns)

各ポッドは、与えられたアプリケーションの単一のインスタンスを稼働するためのものです。もしユーザのアプリケーションを水平にスケーリングさせたい場合(例: 複数インスタンスを稼働させる)、複数のポッドを使うべきです。1つのポッドは各インスタンスに対応しています。
Kubernetesにおいて、これは一般的に_レプリケーション_ と呼ばれます。  
レプリケーションされたポッドは、通常コントローラと呼ばれる抽象概念によって単一のグループとして作成、管理されます。  
さらなる情報に関しては[ポッドとコントローラ](#pods-and-controllers)を参照して下さい。

### ポッドがどのように複数のコンテナを管理しているか

ポッドは凝集性の高いサービスのユニットを構成するような複数の協調プロセス(コンテナ）をサポートするためにデザインされました。
単一のポッド内のコンテナ群は、クラスタ内において同一の物理マシンもしくは仮想マシン上において自動で同じ環境に配備され、スケジュールされます。コンテナはリソースや依存関係を共有し、お互いにコミュニケートし、それらがいつ、どのように削除されるかを調整できます。

注意点として、単一のポッド内で同じ環境に配備され、同時管理される複数のコンテナをグルーピングするのは、比較的に発展的なユースケースとなります。
ユーザは、コンテナ群が密接に連携するような、特定のインスタンスにおいてのみこのパターンを使用するべきです。
例えば、ユーザが共有ボリューム内にあるファイル用のWebサーバとして稼働するコンテナと、下記のダイアグラムにあるような、リモートのソースからファイルを更新するような分離された*サイドカー* コンテナを持っているような場合です。


{{< figure src="/images/docs/pod.svg" title="ポッドのダイアグラム" width="50%" >}}

ポッドは、ポッドによって構成されたコンテナ群のために2種類の共有リソースを提供します。 *ネットワーキング* と*ストレージ* です。

#### ネットワーキング

各ポッドは固有のIPアドレスを割り当てられます。単一のポッド内の各コンテナは、IPアドレスやネットワークポートを含む、そのネットワークの名前空間を共有します。*ポッド内の* コンテナは`localhost`を使用してお互いに疎通できます。単一のポッド内のコンテナが*ポッド外* のエンティティと疎通する場合、共有されたネットワークリソース(ポートなど）をどのように使うかに関して調整しなければなりません。

#### ストレージ

単一のポッドは共有されたストレージ*ボリューム* のセットを指定できます。ポッド内の全てのコンテナは、その共有されたボリュームにアクセスでき、コンテナ間でデータを共有することを可能にします。ボリュームもまた、もしポッド内のコンテナの1つが再起動が必要になった場合に備えて、データを永続化できます。  
単一のポッド内での共有ストレージをKubernetesがどう実装しているかについてのさらなる情報については、[ボリューム](/docs/concepts/storage/volumes/)を参照してください。

## ポッドを利用する

ユーザはまれに、Kubenetes内で独立したポッドを直接作成する場合があります(シングルトンポッドなど)。
これはポッドが比較的、一時的な使い捨てエンティティとしてデザインされているためです。ポッドが作成された時（ユーザによって直接的、またはコントローラによって間接的に作成された場合）、ユーザのクラスタ内の単一のノード上で稼働するようにスケジューリングされます。そのポッドはプロセスが停止されたり、ポッドオブジェクトが削除されたり、ポッドがリソースの欠如のために*追い出され* たり、ノードが故障するまでノード上に残り続けます。

{{< note >}}
単一のポッド内でのコンテナを再起動することと、そのポッドを再起動することを混同しないでください。ポッドはそれ自体は実行されませんが、コンテナが実行される環境であり、削除されるまで存在し続けます。
{{< /note >}}

ポッドは、ポッドそれ自体によって自己修復しません。もし、稼働されていないノード上にポッドがスケジュールされた場合や、スケジューリング操作自体が失敗した場合、ポッドが削除されます。同様に、ポッドはリソースの欠如や、ノードのメンテナンスによる追い出しがあった場合はそこで停止します。Kubernetesは*コントローラ* と呼ばれる高レベルの抽象概念を使用し、それは比較的使い捨て可能なポッドインスタンスの管理を行います。  
このように、ポッドを直接使うのは可能ですが、コントローラを使用したポッドを管理する方がより一般的です。Kubernetesがポッドのスケーリングと修復機能を実現するためにコントローラをどのように使うかに関する情報は[ポッドとコントローラ](#pods-and-controllers)を参照してください。

### ポッドとコントローラ

単一のコントローラは、ユーザのために複数のポッドを作成・管理し、レプリケーションやロールアウト、クラスタのスコープ内で自己修復の機能をハンドリングします。例えば、もしノードが故障した場合、コントローラは異なるノード上にポッドを置き換えるようにスケジューリングすることで、自動的にリプレース可能となります。

1つまたはそれ以上のポッドを含むコントローラの例は下記の通りです。
Some examples of Controllers that contain one or more pods include:

* [デプロイメント](/docs/concepts/workloads/controllers/deployment/)
* [ステートフルセット](/docs/concepts/workloads/controllers/statefulset/)
* [デーモンセット](/docs/concepts/workloads/controllers/daemonset/)

通常は、コントローラはユーザが作成したポッドテンプレートを使用して、担当するポッドを作成します。

## ポッドテンプレート

ポッドテンプレートは、[レプリケーションコントローラ](/docs/concepts/workloads/controllers/replicationcontroller/)、 [ジョブ](/docs/concepts/jobs/run-to-completion-finite-workloads/)や、
[デーモンセット](/docs/concepts/workloads/controllers/daemonset/)のような他のオブジェクト内で含まれるポッドの仕様となります。
コントローラは実際のポッドを作成するためにポッドテンプレートを使用します。  
下記のサンプルは、メッセージを表示する単一のコンテナを含んだ、シンプルなポッドのマニフェストとなります。

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: myapp-pod
  labels:
    app: myapp
spec:
  containers:
  - name: myapp-container
    image: busybox
    command: ['sh', '-c', 'echo Hello Kubernetes! && sleep 3600']
```

全てのレプリカの現在の理想的な状態を指定するというよりも、ポッドテンプレートはクッキーの抜き型のようなものです。一度クッキーがカットされると、そのクッキーは抜き型から離れて関係が無くなります。そこにはいわゆる”量子もつれ”といったものはありません。テンプレートに対するその後の変更や新しいテンプレートへの切り替えは、すでに作成されたポッド上には直接的な影響はありません。
同様に、レプリケーションコントローラによって作成されたポッドは、変更後に直接更新されます。これはポッドとの意図的な違いとなり、そのポッドに属する全てのコンテナの現在の理想的な状態を指定します。このアプローチは根本的にシステムのセマンティクスを単純化し、機能の柔軟性を高めます。

{{% /capture %}}

{{% capture whatsnext %}}
* ポッドの振る舞いに関して学ぶには下記を参照してください。
  * [ポッドの停止](/docs/concepts/workloads/pods/pod/#termination-of-pods)
  * [ポッドのライフサイクル](/docs/concepts/workloads/pods/pod-lifecycle/)
{{% /capture %}}
