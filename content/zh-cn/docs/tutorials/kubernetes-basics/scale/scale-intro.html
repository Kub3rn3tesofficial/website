---
title: 运行应用程序的多个实例
weight: 10
description: |-
  使用 kubectl 手动扩缩现有应用程序。
---

<!--
---
title: Running Multiple Instances of Your App
weight: 10
description: |-
  Scale an existing app manually using kubectl.
---
-->

<!DOCTYPE html>

<html lang="zh">

<body>

<div class="layout" id="top">

    <main class="content">

        <div class="row">

     <div class="col-md-8">

          <!--
          <h3>Objectives</h3>
          -->

          <h3>目标</h3>

                <ul>

                    <!--
                    <li>Scale an app using kubectl.</li>
                    -->

                    <li>使用 kubectl 扩缩应用程序。</li>

                </ul>
            </div>

            <div class="col-md-8">

       <!--
       <h3>Scaling an application</h3>
       -->

       <h3>扩缩应用程序</h3>

            <!--
            <p>Previously we created a <a href="/docs/concepts/workloads/controllers/deployment/"> Deployment</a>, and then exposed it publicly via a <a href="/docs/concepts/services-networking/service/">Service</a>. The Deployment created only one Pod for running our application.  When traffic increases, we will need to scale the application to keep up with user demand.</p>
            <p>If you haven't worked through the earlier sections, start from <a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">Using minikube to create a cluster</a>.</p>

            <p><em>Scaling</em> is accomplished by changing the number of replicas in a Deployment</p>
            <p> <b> NOTE </b> If you are trying this after <a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">the previous section </a>, you may need to start from <a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">creating a cluster</a> as the services may have been deleted </p>
            -->

            <p>之前我们创建了一个 <a href="/docs/concepts/workloads/controllers/deployment/"> Deployment</a>, 然后通过一个 <a href="/docs/concepts/services-networking/service/">Service</a> 公开它。这个 Deployment 仅创建了一个 Pod 来运行我们的应用程序。 当流量增加时，我们需要扩展应用程序以满足用户需求。</p>
            <p>如果你尚未完成前面的部分，请从<a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/">使用 minikube 创建集群</a>开始。</p>

            <p><em>扩缩</em> 通过更改 Deployment 中的副本数量来完成。</p>
            <p> <b> 注意 </b> 如果你在 <a href="/docs/tutorials/kubernetes-basics/expose/expose-intro/">上一节</a>之后尝试此操作, 则可能需要从 <a href="/docs/tutorials/kubernetes-basics/create-cluster/cluster-intro/"> 创建集群 </a>作为开始，因为服务可能已被删除。</p>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_lined">

                    <!--
                    <h3>Summary:</h3>
                    -->

                    <h3>概括：</h3>

                    <ul>

                        <!--
                        <li>Scaling a Deployment</li>
                        -->

                        <li>扩缩部署</li>

                    </ul>

                </div>
                <div class="content__box content__box_fill">

                    <!--
                    <p><i> You can create from the start a Deployment with multiple instances using the --replicas parameter for the kubectl create deployment command </i></p>
                    -->

                    <p><i> 你可以使用 kubectl create deployment 命令的 --replicas 参数从一开始就创建具有多个实例的 Deployment </i></p>

                </div>
            </div>
        </div>
        <br>

        <div class="row">
            <div class="col-md-8">

                <!--
                <h2 style="color: #3771e3;">Scaling overview</h2>
                -->

                <h2 style="color: #3771e3;">扩缩概述</h2>

            </div>
        </div>

        <div class="row">
            <div class="col-md-1"></div>
            <div class="col-md-8">
                <div id="myCarousel" class="carousel" data-ride="carousel" data-interval="3000">
                    <ol class="carousel-indicators">
                        <li data-target="#myCarousel" data-slide-to="0" class="active"></li>
                        <li data-target="#myCarousel" data-slide-to="1"></li>
                    </ol>
                      <div class="carousel-inner" role="listbox">
                        <div class="item carousel-item active">
                          <img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling1.svg">
                        </div>

                        <div class="item carousel-item">
                          <img src="/docs/tutorials/kubernetes-basics/public/images/module_05_scaling2.svg">
                        </div>
                      </div>

                      <a class="left carousel-control" href="#myCarousel" role="button" data-slide="prev">
                        <span class="sr-only ">Previous</span>
                      </a>
                      <a class="right carousel-control" href="#myCarousel" role="button" data-slide="next">
                        <span class="sr-only">Next</span>
                      </a>

                    </div>
            </div>
        </div>

        <br>

        <div class="row">
            <div class="col-md-8">

                <!--
                <p>Scaling out a Deployment will ensure new Pods are created and scheduled to Nodes with available resources. Scaling will increase the number of Pods to the new desired state. Kubernetes also supports <a href="/docs/tasks/run-application/horizontal-pod-autoscale/">autoscaling</a> of Pods, but it is outside of the scope of this tutorial. Scaling to zero is also possible, and it will terminate all Pods of the specified Deployment.</p>
                -->

                <p>扩缩的 Deployment 将确保创建新的 Pod 并将其调度到具有可用资源的节点。 扩缩会将 Pod 数量增加到新的所需状态。 Kubernetes 还支持 Pod 的<a href="/docs/tasks/run-application/horizontal-pod-autoscale/">自动扩缩</a>，但这超出了本教程的范围。也可以缩放到零，并且它将终止指定 Deployment 的所有 Pod。</p>

                <!--
                <p>Running multiple instances of an application will require a way to distribute the traffic to all of them. Services have an integrated load-balancer that will distribute network traffic to all Pods of an exposed Deployment. Services will monitor continuously the running Pods using endpoints, to ensure the traffic is sent only to available Pods.</p>
                -->

                <p>运行应用程序的多个实例将需要一种将流量分配给所有实例的方法。 Services 有一个集成的负载均衡器，它将网络流量分配到公开的 Deployment 的所有 Pod。 Services 将使用端点持续监控正在运行的 Pod，以确保流量仅发送到可用的 Pod。</p>

            </div>
            <div class="col-md-4">
                <div class="content__box content__box_fill">

                    <!--
                    <p><i>Scaling is accomplished by changing the number of replicas in a Deployment.</i></p>
                    -->

                    <p><i>扩缩是通过更改 Deployment 中的副本数量来实现的。</i></p>

                </div>
            </div>
        </div>

        <br>

        <div class="row">
            <div class="col-md-8">

              <!--
              <p> Once you have multiple instances of an application running, you would be able to do Rolling updates without downtime. We'll cover that in the next section of the tutorial. Now, let's go to the terminal and scale our application.</p>
              -->

              <p> 当应用程序的多个实例正在运行时，你就可以在不停机的情况下进行滚动更新。 我们将在本教程的下一部分中介绍这一点。现在，让我们转到终端并扩展我们的应用程序。</p>

            </div>
        </div>

        <div class="row">
            <div class="col-md-12">

                <!--
                <h3>Scaling a Deployment</h3>
                <p>To list your Deployments, use the <code>get deployments</code> subcommand:</p>
                <p><code><b>kubectl get deployments</b></code></p>
                <p>The output should be similar to:</p>
<pre>
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           11m
</pre>
-->

                <h3>扩容</h3>
                <p>要列出你的 Deployment，请使用 <code>get deployments</code> 子命令：</p>
                <p><code><b>kubectl get deployments</b></code></p>
                <p>输出应类似于：</p>
<pre>
NAME                  READY   UP-TO-DATE   AVAILABLE   AGE
kubernetes-bootcamp   1/1     1            1           11m
</pre>

               <!--
               <p>We should have 1 Pod. If not, run the command again. This shows:</p>
               <ul>
               <li><em>NAME</em> lists the names of the Deployments in the cluster.</li>
               <li><em>READY</em> shows the ratio of CURRENT/DESIRED replicas</li>
               <li><em>UP-TO-DATE</em> displays the number of replicas that have been updated to achieve the desired state.</li>
               <li><em>AVAILABLE</em> displays how many replicas of the application are available to your users.</li>
               <li><em>AGE</em> displays the amount of time that the application has been running.</li>
               </ul>
               -->

                <p>我们应该有 1 个 Pod。如果没有，请再次运行该命令。由此可见：</p>
                <ul>
                  <li><em>NAME</em> 列出集群中 Deployment 的名称。</li>
                  <li><em>READY</em> 显示当前/所需副本的比率。</li>
                  <li><em>UP-TO-DATE</em> 显示已更新以达到所需状态的副本数量。</li>
                  <li><em>AVAILABLE</em> 显示有多少个应用程序副本可供你的用户使用。</li>
                  <li><em>AGE</em> 显示应用程序已运行的时间。</li>
                </ul>

               <!--
               <p>To see the ReplicaSet created by the Deployment, run:</p>
               <p><code><b>kubectl get rs</b></code></p>
               -->

               <p>要查看 Deployment 创建的 ReplicaSet，请运行：</p>
               <p><code><b>kubectl get rs</b></code></p>

               <!--
               <p>Notice that the name of the ReplicaSet is always formatted as <tt>[DEPLOYMENT-NAME]-[RANDOM-STRING]</tt>. The random string is randomly generated and uses the <em>pod-template-hash</em> as a seed.</p>
               <p>Two important columns of this output are:</p>
               <ul>
               <li><em>DESIRED</em> displays the desired number of replicas of the application, which you define when you create the Deployment. This is the desired state.</li>
               <li><em>CURRENT</em> displays how many replicas are currently running.</li>
               </ul>
               -->

               <p>请注意，ReplicaSet 的名称始终采用 <tt>[DEPLOYMENT-NAME]-[RANDOM-STRING]</tt> 格式。随机字符串是随机生成的，并使用 <em>pod-template-hash</em> 作为种子。</p>
               <p>此输出的两个重要列：</p>
               <ul>
                 <li><em>DESIRED</em> 显示所需的应用程序副本数量，该数量是你在创建部署时定义的。这是期望的状态。</li>
                 <li><em>CURRENT</em> 显示当前正在运行的副本数量。</li>
               </ul>

               <!--
               <p>Next, let’s scale the Deployment to 4 replicas. We’ll use the <code>kubectl scale</code> command, followed by the Deployment type, name and desired number of instances:</p>
               <p><code><b>kubectl scale deployments/kubernetes-bootcamp --replicas=4</b></code></p>
               <p>To list your Deployments once again, use <code>get deployments</code>:</p>
               <p><code><b>kubectl get deployments</b></code></p>
               <p>The change was applied, and we have 4 instances of the application available. Next, let’s check if the number of Pods changed:</p>
               <p><code><b>kubectl get pods -o wide</b></code></p>
               <p>There are 4 Pods now, with different IP addresses. The change was registered in the Deployment events log. To check that, use the describe subcommand:</p>
               <p><code><b>kubectl describe deployments/kubernetes-bootcamp</b></code></p>
               <p>You can also view in the output of this command that there are 4 replicas now.</p>
               -->

               <p>接下来，我们将 Deployment 扩容到 4 个副本。我们将使用 <code>kubectl scale</code> 命令，后跟部署类型、名称和所需的实例数量：</p>
               <p><code><b>kubectl scale deployments/kubernetes-bootcamp --replicas=4</b></code></p>
               <p>要再次列出你的 Deployment，请使用 <code>get deployments</code>:</p>
               <p><code><b>kubectl get deployments</b></code></p>
               <p>更改已应用，并且我们有 4 个可用的应用程序实例。接下来，我们检查 Pod 数量是否发生变化：</p>
               <p><code><b>kubectl get pods -o wide</b></code></p>
               <p>现在有 4 个具有不同的 IP 地址 Pod。更改记录会记录在部署事件日志中。若要查看是否正确，请使用describe子命令：</p>
               <p><code><b>kubectl describe deployments/kubernetes-bootcamp</b></code></p>
               <p>你还可以在此命令的输出中看到现在有 4 个副本。</p>

            </div>
        </div>

        <div class="row">
            <div class="col-md-12">

                <!--
                <h3>Load Balancing</h3>
                <p>Let's check that the Service is load-balancing the traffic. To find out the exposed IP and Port we can use the describe service as we learned in the previous part of the tutorial:</p>
                <p><code><b>kubectl describe services/kubernetes-bootcamp</b></code></p>
                <p>Create an environment variable called <tt>NODE_PORT</tt> that has a value as the Node port:</p>
                <p><code><b>export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')"</b></code><br />
                <p><code><b>echo NODE_PORT=$NODE_PORT</b></code></p>
                <p>Next, we’ll do a <code>curl</code> to the exposed IP address and port. Execute the command multiple times:</p>
                <p><code><b>curl http://"$(minikube ip):$NODE_PORT"</b></b></b></code></p>
                <p>We hit a different Pod with every request. This demonstrates that the load-balancing is working.</p>
                -->

                <h3>负载均衡</h3>
                <p>让我们检查服务是否正在对流量进行负载平衡。要找出暴露的 IP 和 Port，我们可以使用描述 service，正如我们在教程前一部分中学到的那样：</p>
                <p><code><b>kubectl describe services/kubernetes-bootcamp</b></code></p>
                <p>创建一个名为 <tt>NODE_PORT</tt> 的环境变量，其值为节点 Port：</p>
                <p><code><b>export NODE_PORT="$(kubectl get services/kubernetes-bootcamp -o go-template='{{(index .spec.ports 0).nodePort}}')"</b></code><br />
                <p><code><b>echo NODE_PORT=$NODE_PORT</b></code></p>
                <p>接下来，我们将对暴露的 IP 和 Port 进行 <code>curl</code>。多次执行命令：</p>
                <p><code><b>curl http://"$(minikube ip):$NODE_PORT"</b></b></b></code></p>
                <p>我们每个请求会命中不同的 Pod。这证明了负载平衡正在发挥作用。</p>

            </div>
        </div>

        <div class="row">
            <div class="col-md-12">

               <!--
               <h3>Scale Down</h3>
               <p>To scale down the Deployment to 2 replicas, run again the <code>scale</code> subcommand:</p>
               <p><code><b>kubectl scale deployments/kubernetes-bootcamp --replicas=2</b></code></p>
               <p>List the Deployments to check if the change was applied with the <code>get deployments</code> subcommand:</p>
               <p><code><b>kubectl get deployments</b></code></p>
               <p>The number of replicas decreased to 2. List the number of Pods, with <code>get pods</code>:</p>
               <p><code><b>kubectl get pods -o wide</b></code></p>
               <p>This confirms that 2 Pods were terminated.</p>
               -->

               <h3>缩容</h3>
               <p>要将 Deployment 缩容到 2 个副本，请再次运行 <code>scale</code> 子命令：</p>
               <p><code><b>kubectl scale deployments/kubernetes-bootcamp --replicas=2</b></code></p>
               <p>列出部署以检查是否已应用更改，使用 <code>get deployments</code> 子命令：</p>
               <p><code><b>kubectl get deployments</b></code></p>
               <p>副本数量减少到 2 个。查看 Pod 数量，使用 <code>get pods</code>:</p>
               <p><code><b>kubectl get pods -o wide</b></code></p>
               <p>这确认了 2 个 Pod 已被终止。</p>

            </div>
        </div>

      <div class="row">

          <!--
          <p>
            Once you're ready, move on to <a href="/docs/tutorials/kubernetes-basics/update/update-intro/" title="Performing a Rolling Update">Performing a Rolling Update</a>.</p>
          </p>
          -->

          <p>
            准备就绪后，请继续 <a href="/docs/tutorials/kubernetes-basics/update/update-intro/" title="Performing a Rolling Update">执行滚动更新</a>。</p>
          </p>

      </div>

    </main>

</div>

</body>
</html>
