---
title: 審計
content_type: concept
---
<!--
reviewers:
- soltysh
- sttts
- ericchiang
content_type: concept
title: Auditing
-->
<!-- overview -->

{{< feature-state state="beta" >}}

<!--
Kubernetes _auditing_ provides a security-relevant, chronological set of records documenting
the sequence of actions in a cluster. The cluster audits the activities generated by users,
by applications that use the Kubernetes API, and by the control plane itself.

Auditing allows cluster administrators to answer the following questions:
-->
Kubernetes _審計（Auditing）_ 功能提供了與安全相關的、按時間順序排列的記錄集，
記錄每個使用者、使用 Kubernetes API 的應用以及控制面自身引發的活動。

審計功能使得叢集管理員能夠回答以下問題：

<!--
 - what happened?
 - when did it happen?
 - who initiated it?
 - on what did it happen?
 - where was it observed?
 - from where was it initiated?
 - to where was it going?
-->
 - 發生了什麼？
 - 什麼時候發生的？
 - 誰觸發的？
 - 活動發生在哪個（些）物件上？
 - 在哪觀察到的？
 - 它從哪觸發的？
 - 活動的後續處理行為是什麼？

<!-- body -->

<!--
Audit records begin their lifecycle inside the
[kube-apiserver](/docs/reference/command-line-tools-reference/kube-apiserver/)
component. Each request on each stage
of its execution generates an audit event, which is then pre-processed according to
a certain policy and written to a backend. The policy determines what's recorded
and the backends persist the records. The current backend implementations
include logs files and webhooks.
-->
審計記錄最初產生於
[kube-apiserver](/zh-cn/docs/reference/command-line-tools-reference/kube-apiserver/)
內部。每個請求在不同執行階段都會生成審計事件；這些審計事件會根據特定策略
被預處理並寫入後端。策略確定要記錄的內容和用來儲存記錄的後端。
當前的後端支援日誌檔案和 webhook。

<!--
Each request can be recorded with an associated _stage_. The defined stages are:

- `RequestReceived` - The stage for events generated as soon as the audit
  handler receives the request, and before it is delegated down the handler
  chain.
- `ResponseStarted` - Once the response headers are sent, but before the
  response body is sent. This stage is only generated for long-running requests
  (e.g. watch).
- `ResponseComplete` - The response body has been completed and no more bytes
  will be sent.
- `Panic` - Events generated when a panic occurred.
-->
每個請求都可被記錄其相關的 _階段（stage）_。已定義的階段有：

- `RequestReceived` - 此階段對應審計處理器接收到請求後，並且在委託給
  其餘處理器之前生成的事件。
- `ResponseStarted` - 在響應訊息的頭部發送後，響應訊息體傳送前生成的事件。
  只有長時間執行的請求（例如 watch）才會生成這個階段。
- `ResponseComplete` - 當響應訊息體完成並且沒有更多資料需要傳輸的時候。
- `Panic` - 當 panic 發生時生成。

<!-- 
The configuration of an
[Audit Event configuration](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event)
is different from the
[Event](/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#event-v1-core)
API object.
-->
{{< note >}}
[審計事件配置](/zh-cn/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event)
的配置與 [Event](/zh-cn/docs/reference/generated/kubernetes-api/{{< param "version" >}}/#event-v1-core)
API 物件不同。
{{< /note >}}

<!--
The audit logging feature increases the memory consumption of the API server
because some context required for auditing is stored for each request.
Additionally, memory consumption depends on the audit logging configuration.
-->
審計日誌記錄功能會增加 API server 的記憶體消耗，因為需要為每個請求儲存審計所需的某些上下文。
此外，記憶體消耗取決於審計日誌記錄的配置。

<!--
## Audit Policy

Audit policy defines rules about what events should be recorded and what data
they should include. The audit policy object structure is defined in the
[`audit.k8s.io` API group](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy).
When an event is processed, it's
compared against the list of rules in order. The first matching rule sets the
_audit level_ of the event. The defined audit levels are:
-->
## 審計策略  {#audit-policy}

審計政策定義了關於應記錄哪些事件以及應包含哪些資料的規則。
審計策略物件結構定義在
[`audit.k8s.io` API 組](/zh-cn/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy)
處理事件時，將按順序與規則列表進行比較。第一個匹配規則設定事件的
_審計級別（Audit Level）_。已定義的審計級別有：

<!--
- `None` - don't log events that match this rule.
- `Metadata` - log request metadata (requesting user, timestamp, resource,
  verb, etc.) but not request or response body.
- `Request` - log event metadata and request body but not response body.
  This does not apply for non-resource requests.
- `RequestResponse` - log event metadata, request and response bodies.
  This does not apply for non-resource requests.
-->
- `None` - 符合這條規則的日誌將不會記錄。
- `Metadata` - 記錄請求的元資料（請求的使用者、時間戳、資源、動詞等等），
  但是不記錄請求或者響應的訊息體。
- `Request` - 記錄事件的元資料和請求的訊息體，但是不記錄響應的訊息體。
  這不適用於非資源型別的請求。
- `RequestResponse` - 記錄事件的元資料，請求和響應的訊息體。這不適用於非資源型別的請求。

<!--
You can pass a file with the policy to `kube-apiserver`
using the `--audit-policy-file` flag. If the flag is omitted, no events are logged.
Note that the `rules` field __must__ be provided in the audit policy file.
A policy with no (0) rules is treated as illegal.

Below is an example audit policy file:
-->
你可以使用 `--audit-policy-file` 標誌將包含策略的檔案傳遞給 `kube-apiserver`。
如果不設定該標誌，則不記錄事件。
注意 `rules` 欄位 __必須__ 在審計策略檔案中提供。沒有（0）規則的策略將被視為非法配置。

以下是一個審計策略檔案的示例：

{{< codenew file="audit/audit-policy.yaml" >}}

<!--
You can use a minimal audit policy file to log all requests at the `Metadata` level:
-->
你可以使用最低限度的審計策略檔案在 `Metadata` 級別記錄所有請求：

```yaml
# 在 Metadata 級別為所有請求生成日誌
apiVersion: audit.k8s.io/v1beta1
kind: Policy
rules:
- level: Metadata
```

<!--
If you're crafting your own audit profile, you can use the audit profile for Google Container-Optimized OS as a starting point. You can check the
[configure-helper.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh)
script, which generates the audit policy file. You can see most of the audit policy file by looking directly at the script.

You can also refer to the [`Policy` configuration reference](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy)
for details about the fields defined.
-->
如果你在打磨自己的審計配置檔案，你可以使用為 Google Container-Optimized OS
設計的審計配置作為出發點。你可以參考
[configure-helper.sh](https://github.com/kubernetes/kubernetes/blob/master/cluster/gce/gci/configure-helper.sh)
指令碼，該指令碼能夠生成審計策略檔案。你可以直接在指令碼中看到審計策略的絕大部份內容。

你也可以參考 [`Policy` 配置參考](/zh-cn/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Policy)
以獲取有關已定義欄位的詳細資訊。

<!--
## Audit backends

Audit backends persist audit events to an external storage.
Out of the box, the kube-apiserver provides two backends:

- Log backend, which writes events into the filesystem
- Webhook backend, which sends events to an external HTTP API

In all cases, audit events follow a structure defined by the Kubernetes API in the
[`audit.k8s.io` API group](/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event).
-->

## 審計後端   {#audit-backends}

審計後端實現將審計事件匯出到外部儲存。`Kube-apiserver` 預設提供兩個後端：

- Log 後端，將事件寫入到檔案系統
- Webhook 後端，將事件傳送到外部 HTTP API

在這所有情況下，審計事件均遵循 Kubernetes API 在
[`audit.k8s.io` API 組](/zh-cn/docs/reference/config-api/apiserver-audit.v1/#audit-k8s-io-v1-Event)
中定義的結構。

<!--
In case of patches, request body is a JSON array with patch operations, not a JSON object
with an appropriate Kubernetes API object. For example, the following request body is a valid patch
request to `/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name`.
-->
{{< note >}}
對於 patch 請求，請求的訊息體需要是設定 patch 操作的 JSON 所構成的一個串，
而不是一個完整的 Kubernetes API 物件 JSON 串。
例如，以下的示例是一個合法的 patch 請求訊息體，該請求對應
`/apis/batch/v1/namespaces/some-namespace/jobs/some-job-name`。

```json
[
  {
    "op": "replace",
    "path": "/spec/parallelism",
    "value": 0
  },
  {
    "op": "remove",
    "path": "/spec/template/spec/containers/0/terminationMessagePolicy"
  }
]
```
{{< /note >}}

<!--
### Log backend

The log backend writes audit events to a file in [JSONlines](https://jsonlines.org/) format.
You can configure the log audit backend using the following `kube-apiserver` flags:

Log backend writes audit events to a file in JSON format. You can configure
log audit backend using the following [kube-apiserver][kube-apiserver] flags:
-->
### Log 後端

Log 後端將審計事件寫入 [JSONlines](https://jsonlines.org/)  格式的檔案。
你可以使用以下 `kube-apiserver` 標誌配置 Log 審計後端：

<!--
- `--audit-log-path` specifies the log file path that log backend uses to write
  audit events. Not specifying this flag disables log backend. `-` means standard out
- `--audit-log-maxage` defined the maximum number of days to retain old audit log files
- `--audit-log-maxbackup` defines the maximum number of audit log files to retain
- `--audit-log-maxsize` defines the maximum size in megabytes of the audit log file before it gets rotated
-->
- `--audit-log-path` 指定用來寫入審計事件的日誌檔案路徑。不指定此標誌會禁用日誌後端。`-` 意味著標準化
- `--audit-log-maxage` 定義保留舊審計日誌檔案的最大天數
- `--audit-log-maxbackup` 定義要保留的審計日誌檔案的最大數量
- `--audit-log-maxsize` 定義審計日誌檔案的最大大小（兆位元組）

<!--
If your cluster's control plane runs the kube-apiserver as a Pod, remember to mount the `hostPath`
to the location of the policy file and log file, so that audit records are persisted. For example:
-->
如果你的叢集控制面以 Pod 的形式執行 kube-apiserver，記得要透過 `hostPath`
捲來訪問策略檔案和日誌檔案所在的目錄，這樣審計記錄才會持久儲存下來。例如：

```shell
  --audit-policy-file=/etc/kubernetes/audit-policy.yaml
  --audit-log-path=/var/log/kubernetes/audit/audit.log
```

接下來掛載資料卷：

```yaml
volumeMounts:
  - mountPath: /etc/kubernetes/audit-policy.yaml
    name: audit
    readOnly: true
  - mountPath: /var/log/kubernetes/audit/
    name: audit-log
    readOnly: false
```

<!-- 
and finally configure the `hostPath`:
-->
最後配置 `hostPath`：

```yaml
...
volumes:
- name: audit
  hostPath:
    path: /etc/kubernetes/audit-policy.yaml
    type: File

- name: audit-log
  hostPath:
    path: /var/log/kubernetes/audit/
    type: DirectoryOrCreate
```

<!--
### Webhook backend

The webhook audit backend sends audit events to a remote web API, which is assumed to
be a form of the Kubernetes API, including means of authentication. You can configure
a webhook audit backend using the following kube-apiserver flags:
-->
### Webhook 後端   {#webhook-backend}

Webhook 後端將審計事件傳送到遠端 Web API，該遠端 API 應該暴露與 `kube-apiserver`
形式相同的 API，包括其身份認證機制。你可以使用如下 kube-apiserver 標誌來配置
Webhook 審計後端：

<!--
- `--audit-webhook-config-file` specifies the path to a file with a webhook
  configuration. The webhook configuration is effectively a specialized
  [kubeconfig](/docs/tasks/access-application-cluster/configure-access-multiple-clusters).
- `--audit-webhook-initial-backoff` specifies the amount of time to wait after the first failed
  request before retrying. Subsequent requests are retried with exponential backoff.

The webhook config file uses the kubeconfig format to specify the remote address of
the service and credentials used to connect to it.
-->
- `--audit-webhook-config-file` 設定 Webhook 配置檔案的路徑。Webhook 配置檔案實際上是一個
  [kubeconfig 檔案](/zh-cn/docs/concepts/configuration/organize-cluster-access-kubeconfig/)。
- `--audit-webhook-initial-backoff` 指定在第一次失敗後重發請求等待的時間。隨後的請求將以指數退避重試。

Webhook 配置檔案使用 kubeconfig 格式指定服務的遠端地址和用於連線它的憑據。

<!--
## Event batching {#batching}

Both log and webhook backends support batching. Using webhook as an example, here's the list of
available flags. To get the same flag for log backend, replace `webhook` with `log` in the flag
name. By default, batching is enabled in `webhook` and disabled in `log`. Similarly, by default
throttling is enabled in `webhook` and disabled in `log`.
-->
## 事件批處理  {#batching}

日誌和 Webhook 後端都支援批處理。以 Webhook 為例，以下是可用引數列表。要獲取日誌
後端的同樣引數，請在引數名稱中將 `webhook` 替換為 `log`。
預設情況下，在 `webhook` 中批處理是被啟用的，在 `log` 中批處理是被禁用的。
同樣，預設情況下，在 `webhook` 中啟用頻寬限制，在 `log` 中禁用頻寬限制。

<!--
  - `--audit-webhook-mode` defines the buffering strategy. One of the following:
  - `batch` - buffer events and asynchronously process them in batches. This is the default.
  - `blocking` - block API server responses on processing each individual event.
  - `blocking-strict` - Same as blocking, but when there is a failure during audit logging at the
     RequestReceived stage, the whole request to the kube-apiserver fails.
-->
- `--audit-webhook-mode` 定義快取策略，可選值如下：
  - `batch` - 以批處理快取事件和非同步的過程。這是預設值。
  - `blocking` - 在 API 伺服器處理每個單獨事件時，阻塞其響應。
  - `blocking-strict` - 與 `blocking` 相同，不過當審計日誌在 RequestReceived 階段
    失敗時，整個 API 服務請求會失效。

<!--
The following flags are used only in the `batch` mode.

- `--audit-webhook-batch-buffer-size` defines the number of events to buffer before batching.
  If the rate of incoming events overflows the buffer, events are dropped.
- `--audit-webhook-batch-max-size` defines the maximum number of events in one batch.
- `--audit-webhook-batch-max-wait` defines the maximum amount of time to wait before unconditionally
  batching events in the queue.
- `--audit-webhook-batch-throttle-qps` defines the maximum average number of batches generated
  per second.
- `--audit-webhook-batch-throttle-burst` defines the maximum number of batches generated at the same
  moment if the allowed QPS was underutilized previously.
-->
以下引數僅用於 `batch` 模式。

- `--audit-webhook-batch-buffer-size` 定義 batch 之前要快取的事件數。
  如果傳入事件的速率溢位快取區，則會丟棄事件。
- `--audit-webhook-batch-max-size` 定義一個 batch 中的最大事件數。
- `--audit-webhook-batch-max-wait` 無條件 batch 佇列中的事件前等待的最大事件。
- `--audit-webhook-batch-throttle-qps` 每秒生成的最大批次數。
- `--audit-webhook-batch-throttle-burst` 在達到允許的 QPS 前，同一時刻允許存在的最大 batch 生成數。

<!--
## Parameter tuning

Parameters should be set to accommodate the load on the API server.

For example, if kube-apiserver receives 100 requests each second, and each request is audited only
on `ResponseStarted` and `ResponseComplete` stages, you should account for ≅200 audit
events being generated each second. Assuming that there are up to 100 events in a batch,
you should set throttling level at least 2 queries per second. Assuming that the backend can take up to
5 seconds to write events, you should set the buffer size to hold up to 5 seconds of events;
that is: 10 batches, or 1000 events.
-->
## 引數調整   {#parameter-tuning}

需要設定引數以適應 API 伺服器上的負載。

例如，如果 kube-apiserver 每秒收到 100 個請求，並且每個請求僅在 `ResponseStarted`
和 `ResponseComplete` 階段進行審計，則應該考慮每秒生成約 200 個審計事件。
假設批處理中最多有 100 個事件，則應將限制級別設定為每秒至少 2 個查詢。
假設後端最多需要 5 秒鐘來寫入事件，你應該設定緩衝區大小以容納最多 5 秒的事件，
即 10 個 batch，即 1000 個事件。

<!--
In most cases however, the default parameters should be sufficient and you don't have to worry about
setting them manually. You can look at the following Prometheus metrics exposed by kube-apiserver
and in the logs to monitor the state of the auditing subsystem.

- `apiserver_audit_event_total` metric contains the total number of audit events exported.
- `apiserver_audit_error_total` metric contains the total number of events dropped due to an error
  during exporting.
-->
但是，在大多數情況下，預設引數應該足夠了，你不必手動設定它們。
你可以檢視 kube-apiserver 公開的以下 Prometheus 指標，並在日誌中監控審計子系統的狀態。

- `apiserver_audit_event_total` 包含所有暴露的審計事件數量的指標。
- `apiserver_audit_error_total` 在暴露時由於發生錯誤而被丟棄的事件的數量。

<!--
### Log entry truncation {#truncate}

Both log and webhook backends support limiting the size of events that are logged.
As an example, the following is the list of flags available for the log backend:
-->
### 日誌條目截斷   {#truncate}

日誌後端和 Webhook 後端都支援限制所輸出的事件的尺寸。
例如，下面是可以為日誌後端配置的標誌列表：

<!--
- `audit-log-truncate-enabled` whether event and batch truncating is enabled.
- `audit-log-truncate-max-batch-size` maximum size in bytes of the batch sent to the underlying backend.
- `audit-log-truncate-max-event-size` maximum size in bytes of the audit event sent to the underlying backend.
-->
- `audit-log-truncate-enabled`：是否棄用事件和批次的截斷處理。
- `audit-log-truncate-max-batch-size`：向下層後端傳送的各批次的最大尺寸位元組數。
- `audit-log-truncate-max-event-size`：向下層後端傳送的審計事件的最大尺寸位元組數。

<!--
By default truncate is disabled in both `webhook` and `log`, a cluster administrator should set
`audit-log-truncate-enabled` or `audit-webhook-truncate-enabled` to enable the feature.
-->
預設情況下，截斷操作在 `webhook` 和 `log` 後端都是被禁用的，叢集管理員需要設定
`audit-log-truncate-enabled` 或 `audit-webhook-truncate-enabled` 標誌來啟用此操作。

## {{% heading "whatsnext" %}}

<!--
* Learn about [Mutating webhook auditing annotations](/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations).
-->
* 瞭解 [Mutating webhook 審計註解](/zh-cn/docs/reference/access-authn-authz/extensible-admission-controllers/#mutating-webhook-auditing-annotations)。

